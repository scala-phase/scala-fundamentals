// Databricks notebook source exported at Fri, 21 Oct 2016 19:48:12 UTC
// MAGIC %md
// MAGIC <img src="http://www.scala-lang.org/resources/img/smooth-spiral.png" style="float: right; height: 100px; margin-right: 50px; margin-top: 20px"/>
// MAGIC # Scala Fundamentals: Basic Types and Expressions
// MAGIC 
// MAGIC Sujan Kapadia
// MAGIC 
// MAGIC <img src="http://chariotsolutions.com/wp-content/uploads/event/2015/11/59fc6d9e-cb95-11e0-816a-5fcb627c2ae5-1.jpg" style="height:64px"/>

// COMMAND ----------

// MAGIC %md 
// MAGIC ## What is Scala?
// MAGIC * A **statically typed** language that runs on the JVM.
// MAGIC * Provides both **_functional_** and **_object-oriented_** constructs.  We will go over these during today's workshop.
// MAGIC * Provides a rich, expressive type system.
// MAGIC * The language and its ecosystem facilitate development of concurrent, non-blocking services.
// MAGIC * **Who**: Martin Odersky 
// MAGIC * **When**: Publicly released in 2004
// MAGIC * **Where**: EPFL
// MAGIC 
// MAGIC ### What is the JVM?
// MAGIC * Java Virtual Machine: A specification and abstract machine that runs Java bytecode.
// MAGIC * Bytecode is a _platform-independent_, intermediate representation.  Java, Groovy, Scala, and Clojure compilers produce bytecode.
// MAGIC * The JVM interprets, optimizes, and compiles bytecode to the target platform it runs on.
// MAGIC 
// MAGIC 
// MAGIC Let's say "Hello Scala" and get a little more familiar with the notebook environment.

// COMMAND ----------

// MAGIC %md 
// MAGIC ### Exercise 1
// MAGIC 1. Below is a blank cell that you can enter code in. (You can create a new cell by clicking on the **+** icon.)
// MAGIC 2. Type in "Hello Scala" (including the double quotes).
// MAGIC 3. To run a cell that has code in it, press **Shift+Enter**

// COMMAND ----------



// COMMAND ----------

// MAGIC %md 
// MAGIC 1. The interactive environment **evaluates** "Hello Scala".  
// MAGIC 2. This environment is known as the **REPL** = Read-Eval-Print Loop.  (The notebook environment is slightly different however.)
// MAGIC 2. It determines a _type_ for the value entered, in this case **String**.
// MAGIC 3. It assigns the value to **res0**, automatically generated by the REPL / environment.

// COMMAND ----------

// MAGIC %md 
// MAGIC ### Exercise 2
// MAGIC 1. Create another cell and type in 42.
// MAGIC 2. What result do you see?

// COMMAND ----------



// COMMAND ----------

// MAGIC %md 
// MAGIC 1. 42 is evaluated.
// MAGIC 2. In this case, the type is _inferred_ as Int.
// MAGIC 3. Int is a 32 bit integer type.

// COMMAND ----------

// MAGIC %md
// MAGIC ### Exercise 3
// MAGIC 1. What's the formula for converting Fahrenheit to Celsius?
// MAGIC 2. Enter an expression that converts **65 degrees Fahrenheit to Celsius**.

// COMMAND ----------

// TODO
// Enter expression

// COMMAND ----------

// ANSWER
(65 - 32) * 5/9

// COMMAND ----------

// MAGIC %md
// MAGIC ## Expressions
// MAGIC * The compiler _evaluated an expression_.  The previous numbers entered are also expressions.
// MAGIC * An expression is evaluated to a **value** that has a **type**.
// MAGIC * Note: Without the parentheses, the multiplication would have been evaluated first.  Scala has [rules for operator precedence](http://www.scala-lang.org/files/archive/spec/2.11/06-expressions.html#infix-operations).

// COMMAND ----------

1 * 5 + 20/4 * (7 - 2)

// COMMAND ----------

// MAGIC %md
// MAGIC ### But something is not quite right.
// MAGIC * Hey the result shouldn't be 18.  
// MAGIC * My calculator returns 18.3333... What gives?
// MAGIC * In the expression we entered, every number is an **Int**.  We will see the significance of this shortly.
// MAGIC * So how can we fix this?

// COMMAND ----------

// MAGIC %md
// MAGIC ### Exercise 4
// MAGIC 1. Enter in 5.9 and execute the cell.
// MAGIC 2. What did the compiler evaluate the expression as?
// MAGIC 3. A **Double** is a 64-bit floating point type.  (There's also **Float**, which takes up 32 bits) 
// MAGIC 4. Notice that the compiler automatically inferred the type as Double.

// COMMAND ----------



// COMMAND ----------

2 * 7.0

// COMMAND ----------

// MAGIC %md
// MAGIC ## Numeric Literals
// MAGIC 1. A _literal_ means the value is directly specified in the expression.
// MAGIC 2. We can actually tell the compiler what type to treat the literal, by adding a character after the value.
// MAGIC * Float: **f** or **F**
// MAGIC * Double: **d** or **D**
// MAGIC * Long (64 bit integer): **l** or **L**
// MAGIC * Plain integer literals are inferred as **Int**.  As we saw previously, plain decmial literals are inferred as **Double**

// COMMAND ----------

100L


// COMMAND ----------

2f

// COMMAND ----------

9.8D

// COMMAND ----------

// MAGIC %md
// MAGIC ### Exercise 5
// MAGIC 1. Re-enter the temperature conversion expression, but instruct Scala to treat one of the numbers as a Float type.
// MAGIC 2. Run the cell and notice the result and its type.

// COMMAND ----------

// TODO


// COMMAND ----------

// ANSWER
(65f - 32) * 5/9

// COMMAND ----------

// MAGIC %md
// MAGIC ## But why? Number instances are objects.
// MAGIC 1. For **Int**, arithmetic operations that take **Int** also return an **Int**.
// MAGIC 2. For **Float**, the operations that take **Float** also return **Float**
// MAGIC 3. Let's take a look at the [ScalaDoc for Int](http://www.scala-lang.org/api/current/#scala.Int)
// MAGIC 4. Numbers are objects and you can invoke operations on them!
// MAGIC 
// MAGIC 
// MAGIC * **Short**: 16 bit signed integer
// MAGIC * **Int**: 32 bit signed integer
// MAGIC * **Long**: 64 bit signed integer
// MAGIC * **Float**: 32 bit floating point number
// MAGIC * **Double**: 64 bit floating point number

// COMMAND ----------

65536 + 2L

// COMMAND ----------

"Hello World" + 1

// COMMAND ----------

1 + "Hello World"

// COMMAND ----------

"Hello World" * 2

// COMMAND ----------

2 * "Hello World"

// COMMAND ----------

// MAGIC %md
// MAGIC ### Take a look at the ScalaDocs.  Don't just assume!

// COMMAND ----------

// MAGIC %md
// MAGIC ## Strings
// MAGIC * The String type represents a sequence of (Unicode) characters.
// MAGIC * Strings are surrounded by double quotes.
// MAGIC * A single character can be represented with single quotes ('c').  This is represented by the **Char** type.
// MAGIC * Strings also have many [operations](http://www.scala-lang.org/api/current/#scala.collection.immutable.StringOps)
// MAGIC 
// MAGIC 
// MAGIC * String: An **immutable** sequence of characters
// MAGIC * Char: A 16 bit unsigned integer
// MAGIC * **Aside:** Scala Strings are actually Java Strings, but behind the scenes they are _enriched_ with more operations.

// COMMAND ----------

// MAGIC %md
// MAGIC ### Exercise 6 - String operations
// MAGIC 1. What is the length of "Hello Philadelphia"?
// MAGIC 2. In two operations, convert "Hello Philadelphia" to "Yo Philly"
// MAGIC 3. Then add a "!" to the end of it.
// MAGIC 4. Finally, uppercase it.

// COMMAND ----------

// TODO


// COMMAND ----------

// ANSWER
"Hello Philadelphia".length
println("Hello Philadelphia".length)

("Hello Philadelphia".replaceAll("Hello", "Yo").replaceAll("Philadelphia", "Philly") + "!").toUpperCase



// COMMAND ----------

// MAGIC %md
// MAGIC ## Observations
// MAGIC * Operations can be invoked after a **`.`**
// MAGIC * They can be chained together
// MAGIC * Strings also implement the **+** operator.  
// MAGIC * Single line comments start with **//**
// MAGIC * These operations are **functions**.  We will go over functions in more detail in the next session.

// COMMAND ----------

// MAGIC %md
// MAGIC ## Triple Quoted Strings
// MAGIC * You can define multi-line strings
// MAGIC * There's no need to escape special characters (backslashes, etc.)
// MAGIC 
// MAGIC ### Multi-line strings

// COMMAND ----------

"""
  Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo   
  consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
"""

// COMMAND ----------

// MAGIC %md
// MAGIC ### Margin stripping

// COMMAND ----------

"""
  |Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo   
  |consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.
""".stripMargin

// COMMAND ----------

// MAGIC %md
// MAGIC ### Escaping required

// COMMAND ----------

println("You have exceeded the number of login attempts.\nYour account has been locked.\nPlease contact your administrator.")

// COMMAND ----------

// MAGIC %md
// MAGIC ### Escaping not required

// COMMAND ----------

println("""You have exceeded the number of login attempts.\nYour account has been locked.\nPlease contact your administrator.""")

// COMMAND ----------

// MAGIC %md
// MAGIC ## Values
// MAGIC * It would be painful to have to repeat literals and expressions.
// MAGIC * Of course Scala allows us to assign an expression to a _named_ value.
// MAGIC * A value is denoted by the keyword **val**, an identifier, an optional colon and type name, and the assignment

// COMMAND ----------

val personName: String = "John Doe"

val personAge: Int = 36

val ageMessage: String = personName + " is " + personAge + " years old."

// COMMAND ----------

// MAGIC %md
// MAGIC ### Exercise 7
// MAGIC 1. Perform the temperature conversion, but this time assign the result to a **val** and run the cell.
// MAGIC 2. Now remove the colon and type from the val and re-run the cell (or create a new cell).
// MAGIC 3. What happened?

// COMMAND ----------

// TODO


// COMMAND ----------

// ANSWER
val celsiusTemp: Float = (65f - 32) * 5/9
val celsiusTempNoType = (65f - 32) * 5/9

// COMMAND ----------

// MAGIC %md
// MAGIC #### The compiler **inferred** the type, just as before.  If the type cannot be inferred, the compiler will complain.  

// COMMAND ----------

// MAGIC %md
// MAGIC ### Exercise 8a
// MAGIC 1. Try to assign an **Int** literal to a val declared as **String**.
// MAGIC 2. Try to assign a **String** literal to a val declared as **Int**.
// MAGIC 3. What happened?  
// MAGIC 
// MAGIC #### Scala is statically typed.  Types are resolved and _enforced_ at compile time.

// COMMAND ----------

// TODO

// COMMAND ----------

// ANSWER
val name: String = 65

// COMMAND ----------

// ANSWER
val age: Int = "65"

// COMMAND ----------

// MAGIC %md
// MAGIC ### Exercise 8b
// MAGIC 1. Convert an **Int** to a **String**. See the [Scaladoc for Int](http://www.scala-lang.org/api/current/#scala.Int)
// MAGIC 2. Convert a **String** to an **Int**.  See the [Scaladoc for String](http://www.scala-lang.org/api/current/#scala.collection.immutable.StringOps) 
// MAGIC 3. Assign 65536 to a val declared as **Short**.  What happens?
// MAGIC 3. What happens if you try to convert "42abc" to an **Int**.  Try it out.

// COMMAND ----------

// TODO


// COMMAND ----------

// ANSWER
val ageString = 65.toString
val age = "65".toInt

// COMMAND ----------

// ANSWER
val shortInt: Short = 65536

// COMMAND ----------

// ANSWER
"42abc".toInt

// COMMAND ----------

// MAGIC %md
// MAGIC ### Exercise 9
// MAGIC 1. Perform the temperature conversion and assign it to a val.
// MAGIC 2. Afterwards, assign a different value to the **same val**.
// MAGIC 3. What happens?
// MAGIC 
// MAGIC #### Values are _immutable_!
// MAGIC * The compiler will **_not_** permit a val to be reassigned.
// MAGIC * The expression on the right hand side is evaluated _immediately_.  

// COMMAND ----------

// TODO

// COMMAND ----------

// ANSWER
val temp = (65f - 32) * 5/9
temp = temp + 1

// COMMAND ----------

val EarthGravity = 9.807f // Constants are capitalized by convention

// COMMAND ----------

// MAGIC %md
// MAGIC **Constants**: By convention, constants in Scala are capitalized.

// COMMAND ----------

val MarsGravity = 3.711f
val personWeightOnEarth = 140.0f
val message = "On Mars " + personName + " weighs " + (personWeightOnEarth * MarsGravity / EarthGravity) + " pounds"
message.replaceAll("pounds", "lbs.")

// COMMAND ----------

message // Original message did not change.

// COMMAND ----------

// MAGIC %md
// MAGIC ## Variables
// MAGIC * No surprise, _they vary_.  That is, a variable can be reassigned!
// MAGIC * A variable is denoted by the keyword **var**.
// MAGIC 
// MAGIC #### Variables are _mutable_!

// COMMAND ----------

var personHeight: Float = 5.5f

var personAge: Int = 14

// COMMAND ----------

personAge = personAge + 1
personHeight += 0.5f

// COMMAND ----------

var message = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
message = "Blah blah blah    "
message.replaceAll("blah", "foo")
println(message)

// COMMAND ----------

// MAGIC %md
// MAGIC ### Why do we need values then?
// MAGIC * To ensure that a value cannot be reassigned (or corrupted) by multiple threads.
// MAGIC * To compute a value once and be able to refer to it multiple times, where the compiler guarantees it will not be reassigned.
// MAGIC * To define constants, as we've seen.
// MAGIC * When an expression **only contains values**, it is easier to reason about the behavior of the code, as it does not depend on any parts that can be reassigned.  As we will see in later sections, expressions that only contain values, **pure functions**, and **immutable data structures** enhance this further.

// COMMAND ----------

// MAGIC %md
// MAGIC ## Referential Transparency: Part 1
// MAGIC 
// MAGIC * This simply means that expressions that compute values can be replaced by their values without changing the meaning of the program.
// MAGIC * The usage of only immutable values, **val**, satisfies this property.
// MAGIC * This is a benefit of **pure** functional programming.
// MAGIC * Let's see a simple, contrived example.
// MAGIC * We will revisit this in the next session when discussing **pure functions**.

// COMMAND ----------

val currentQuantity = 22
val widgetsOrderedByUser1 = 5
val widgetsOrderedByUser2 = 2
val updatedQuantity = currentQuantity - widgetsOrderedByUser1 - widgetsOrderedByUser2
val inventoryMessage = "There are currently " + (currentQuantity - widgetsOrderedByUser1 - widgetsOrderedByUser2) + " widgets in stock."
val substitutedInventoryMessage = "There are currently " + (updatedQuantity) + " widgets in stock."

// COMMAND ----------

// MAGIC %md 
// MAGIC ## Equality
// MAGIC * A discussion of values without going over equality would be incomplete.  So what does Scala provide to test and define equality?  
// MAGIC * Let's take a look at primitive values like **Int**
// MAGIC * Then we'll look at objects, namely **String**

// COMMAND ----------

// MAGIC %md
// MAGIC ### Primitives: Double Equals ==

// COMMAND ----------

val personAge1 = 36
val personAge2 = 45
val personAge3 = 36

println(personAge1 == personAge1)
println(personAge1 == personAge2)
println(personAge2 == personAge1)
println(personAge1 == personAge3)
println(personAge3 == personAge1)

// COMMAND ----------

// MAGIC %md
// MAGIC ## Primitives: Equals

// COMMAND ----------

println(personAge1.equals(personAge3))
println(personAge1.equals(personAge2))

// COMMAND ----------

// MAGIC %md 
// MAGIC ## So what's the difference?
// MAGIC * **equals** is customizable.  That is, for your own classes, the **equals** method can be **overridden**.
// MAGIC * **==** is **NOT** customizable (i.e. a final method).  The **==** method internally invokes the **equals** method.
// MAGIC * There is also another difference that we will see when we cover **object** equality.
// MAGIC * WARNING:  This is completely different than Java.  In Java, **==** is an operator that performs **_reference_** equality.
// MAGIC * Why?

// COMMAND ----------

// MAGIC %md
// MAGIC ### Gotchas: Number primitives == does not call equals

// COMMAND ----------

println(1 == 1L)
println(1L == 1)
println(1.equals(1L))
println(1L.equals(1))
println(Double.NaN == Double.NaN)
println(Double.NaN.equals(Double.NaN))

// COMMAND ----------

// MAGIC %md
// MAGIC ### Objects: Double Equals ==

// COMMAND ----------

val s1 = "Hello Scala"
val s2 = "Hello Scala"
val s3 = "Goodbye Java"

println(s1 == s1)
println(s1 == s2)
println(s2 == s1)
println(s1 == s3)
println(s1 == null) // Huh what's null?
println(null == s1)

// COMMAND ----------

// MAGIC %md
// MAGIC ## What is null?
// MAGIC * Null denotes that an object reference has NOT been assigned.  
// MAGIC * If you attempt to dereference (perform an operation on) a null object reference, the runtime will throw a **java.lang.NullPointerException**
// MAGIC * The *==* method is **_null safe_**, meaning that it can handle a null reference on either side.  The **equals** method is not null safe in both directions.
// MAGIC 
// MAGIC ### Objects: equals methods

// COMMAND ----------

println(s1.equals(s1))
println(s1.equals(s2))
println(s2.equals(s1))
println(s1.equals(s3))
println(s1.equals(null)) // The operation is being invoked on s1

// COMMAND ----------

println(null.equals(s1)) // The operation is being invoked on null

// COMMAND ----------

// MAGIC %md
// MAGIC ### Primitives cannot be assigned null

// COMMAND ----------

val x: Int = null

// COMMAND ----------

// MAGIC %md
// MAGIC ## Objects: Reference Equality
// MAGIC * Objects are stored in memory (JVM allocated and managed "heap").  
// MAGIC * To test whether two references point to the same object in the heap (same memory location), Scala provides a **eq** method.
// MAGIC * WARNING:  In Java, reference equality is tested with **==**.
// MAGIC 
// MAGIC ### Objects: Reference equality via eq

// COMMAND ----------

val personName1 = "Martin Odersky"
val personName2 = "Adriaan Moors"
val personName3 = "Martin Odersky"

println(personName1 eq personName1)
println(personName1 eq personName2)
println(personName1 eq personName3) // WAIT: Why does this return true ??

val personName1Str = new String("Martin Odersky") // Explicitly instantiating a String
val personName3Str = new String("Martin Odersky")

// Both will evaluate to false.  Why?
println(personName1Str eq personName3Str)
println(personName3Str eq personName1Str)

// COMMAND ----------

// MAGIC %md
// MAGIC ### Both are java.lang.String

// COMMAND ----------

println(personName1.getClass)
println(personName1Str.getClass)

// COMMAND ----------

// MAGIC %md
// MAGIC ### java.lang.Integer objects

// COMMAND ----------

val xInt = new Integer(1)
val yInt = new Integer(1)

println(xInt eq yInt)
println(xInt == yInt)
println(xInt.equals(yInt))

// COMMAND ----------

// MAGIC %md
// MAGIC ### No eq method for primitives

// COMMAND ----------

val x: Int = 1
x eq x

// COMMAND ----------

// MAGIC %md
// MAGIC ### Primitives should not be compared with null

// COMMAND ----------

personAge1 == null
null == personAge1

// COMMAND ----------

// MAGIC %md
// MAGIC ## Boolean 
// MAGIC * The boolean type in Scala is represented by Boolean
// MAGIC * It can take a value of **true** or **false**
// MAGIC * See [ScalaDocs](http://www.scala-lang.org/api/current/#scala.Boolean) for more operations.

// COMMAND ----------

val thisWorkshopRocks: Boolean = true
var isJava8Better = false

// COMMAND ----------

// MAGIC %md
// MAGIC ## String Interpolation
// MAGIC * We have been building messages using the **+** method on Strings, but there is a better way.
// MAGIC * Scala allows us to _insert expressions within_ String literals.  
// MAGIC * Why? Logging, user-friendly error messages, etc.
// MAGIC * The expressions are evaluated as part of the String literal.
// MAGIC * For a String to be "interpolated", it must begin with an **s**, before the starting quote.
// MAGIC * Expressions are surrounded by **${ _expression_ }**
// MAGIC * For directly substituting a **val** or **var**, the curly braces **{ }** can be omitted (I don't prefer this style).

// COMMAND ----------

val EarthGravity = 9.807f
val MarsGravity = 3.711f
val personName = "John Doe"
val personWeightOnEarth = 140.0f
val message = s"On Mars $personName weighs ${(personWeightOnEarth * MarsGravity / EarthGravity)} pounds"

// COMMAND ----------

// MAGIC %md
// MAGIC ## Conditional Expressions
// MAGIC * A conditional expression _conditionally_ evaluates to a value based on one or more logical expressions.
// MAGIC * A logical expression is one that one that evaluates to **true** or **false**, in other words of type **Boolean**
// MAGIC * We've already seen one - equality checks.
// MAGIC 
// MAGIC ### Logical Expressions

// COMMAND ----------

val personAge = 36
val gender = "Female"
println(1 < 2)
println((personAge >= 21) && (gender == "Female"))
println((personAge < 21) || (personAge >= 65))

// COMMAND ----------

// MAGIC %md
// MAGIC ## If, Else If, Else
// MAGIC * How can we make decisions based on logical expressions?
// MAGIC 
// MAGIC <pre>
// MAGIC   if (expression) {
// MAGIC     expressions
// MAGIC   }
// MAGIC   else if (expression) {
// MAGIC     expressions
// MAGIC   }
// MAGIC   else {
// MAGIC     expressions
// MAGIC   }
// MAGIC </pre>

// COMMAND ----------

if (personAge < 21) {
  "No beer for you"
}
else {
  "Here's our draft list."
}

// COMMAND ----------

// MAGIC %md
// MAGIC ## Its an expression!
// MAGIC * Notice the return type of **String**.  
// MAGIC * The if construction is evaluated just like any other expression - to a value with a type.
// MAGIC * The entire if constructions evaluates to a value.
// MAGIC * Also note that in this case the code **did not perform any _side effects_**.
// MAGIC * Note:  If you're a Java developer, this is a strange concept as Java is **statement oriented**.  Statements are executed **_for their side effects_**.
// MAGIC * If the construction contains a single expression, the curly braces **{ }** can be omitted.
// MAGIC * Type inferencing behaves as expected.

// COMMAND ----------

val response = if (personAge < 21) "No beer for you" else "Here's our draft list"

// COMMAND ----------

// MAGIC %md
// MAGIC ## Exercise 10
// MAGIC * We'd like to return a message based on the amount of stock in inventory.
// MAGIC * Greater than 50: "In Stock"
// MAGIC * Less than or equal to 50: "Less than 50 remaining."
// MAGIC * Less than or equal to 10: "Only a few left!"
// MAGIC * Equal to 0: "Out of stock"

// COMMAND ----------

// TODO


// COMMAND ----------

// ANSWER
val inventory = 50
val result = if (inventory > 50) {
  "In Stock"
}
else if (inventory > 10 && inventory <= 50) {
  "Less than 50 remaining"
}
else if (inventory <= 10) {
  "Only a few left!"
}
else if (inventory == 0) {
  "Out of stock"
}

// COMMAND ----------

// MAGIC %md
// MAGIC ## Results
// MAGIC * What was the type of the result? **Any**
// MAGIC * Why?
// MAGIC * **Any** is at the top of the _type hierarchy_.
// MAGIC * Since we did not provide a final **else** branch, the compiler cannot determine the type in the case none of the branches are selected.
// MAGIC * In this case the most common type (_least upperbound_ to be specific) it can resort to is **Any**.
// MAGIC * **Solution**:  Provide an **else** branch with a fallback message so the **String** type can be inferred.

// COMMAND ----------

// ANSWER
val result = if (inventory > 50) {
  "In Stock"
}
else if (inventory > 10 && inventory <= 50) {
  "Less than 50 remaining"
}
else if (inventory <= 10) {
  "Only a few left!"
}
else if (inventory == 0) {
  "Out of stock"
}
else {
  "This shouldn't happen"
}

// COMMAND ----------

// MAGIC %md 
// MAGIC ![Scala Type Hierarchy diagram](http://i.imgur.com/hr7kB5K.png "Scala Type Hierarchy")

// COMMAND ----------

// MAGIC %md
// MAGIC ## Blocks
// MAGIC * What is a **block**?  A sequence of zero or more expressions, surrounded by curly braces **{ }**
// MAGIC * The entire block itself is an expression.
// MAGIC * The value and type of the block is the **_value and type of the final expression in the block_**.
// MAGIC * You'd like to express a computation that takes multiple steps, but resolves to a value.
// MAGIC 
// MAGIC ### No side effects!

// COMMAND ----------

val result = {
  val neverUsed = 5
  val answerToLifeIgnored = 42
  "I'm just a block!"
}

// COMMAND ----------

// MAGIC %md 
// MAGIC ### Side effects!

// COMMAND ----------

var outerVar = true
val result = {
  outerVar = false
  var innerVar = 1
  innerVar += 1
  println(s"Inner var $innerVar")
}
println(result)
println(outerVar)

// COMMAND ----------

// MAGIC %md
// MAGIC ### Generally speaking, side effects and _exposing_ mutable data / state are NOT recommended!
// MAGIC * We should strive to segregate (and minimize) side-effecting code from side-effect free code.  
// MAGIC * This can lead to easier testability, reasoning of behavior, and the possibility for distributing a workload across multiple cores (although this depends on other factors as well).
// MAGIC 
// MAGIC ### Scoping

// COMMAND ----------

var outerVar = true
val result = {
  outerVar = false
  var innerVar = 1
  innerVar += 1
  println(s"Inner var $innerVar")
}
println(innerVar)

// COMMAND ----------

// MAGIC %md
// MAGIC ## Exercise 11: "Scam"azon Prime
// MAGIC * When ordering an item, we'd like to generate a message indicating the number of days it will take to deliver an item.
// MAGIC * Compute the distance between your house and where the item being ordered is located (**Hint: Look at [scala.Math](http://www.scala-lang.org/api/current/index.html#scala.math.package)**)
// MAGIC * Assume the map is a Cartesian plane, with your house at the origin (0,0); both x and y are measured in miles.
// MAGIC * Choose a random (X,Y) coordinate for the item location, where both x and y are between 10 and 2000 inclusive. (**Hint: Look at [scala.util.Random](http://www.scala-lang.org/api/current/index.html#scala.util.Random)**)
// MAGIC * Assume 100 miles = 1 day
// MAGIC * If it is less than 30 miles away, return the message "Come pick up (_insert item name_) yourself!"
// MAGIC * If it is more than 1000 miles away, add an extra 10 days for every 500 miles.
// MAGIC * Round the days up to the next nearest integer.

// COMMAND ----------

// TODO
import scala.util.Random
import scala.math

val itemName = "Programming in Scala Third Edition"

// COMMAND ----------

// ANSWER
import scala.util.Random
import scala.math

// Constants
val MinX = 10
val MaxX = 2000
val MinY = 10
val MaxY = 2000
val MilesPerDay = 100

// Data
val itemName = "Programming in Scala Third Edition"
val rand = new Random()
val destX = rand.nextInt(MaxX - MinX + 1) + MinX 
val destY = rand.nextInt(MaxY - MinY + 1) + MinY

// Computation
val shippingMessage = {
  val distance = Math.sqrt(destX*destX + destY*destY)
  if (distance < 30) {
    s"Come pick up $itemName yourself"
  } else {
    val numDays = {
      if (distance > 1000.0) {
        ((distance - 1000.0) / 500.0) * 10 + (1000.0 / MilesPerDay)
      } 
      else {
        distance / MilesPerDay
      }
    }
    s"Your item, $itemName, will arrive in ${Math.ceil(numDays).toInt} days."
  }
}


// COMMAND ----------

// MAGIC %md
// MAGIC ## Tuples
// MAGIC * Hmm what if you want to return multiple values from a block?
// MAGIC * You could use **vars** to capture multiple changes, but that would mean you are adding mutable code, and then can have unintended side effects and lose referential transparency.
// MAGIC * Or let's say you want to group together values that are logically meant to be together (coordinates, vectors, key-value pairs, etc.)
// MAGIC * Tuples allow you to group multiple values together!

// COMMAND ----------

val personTuple = ("John Doe", 36)

val name = personTuple._1
val age = personTuple._2

val size = personTuple.productArity

val dupPersonTuple = ("John Doe", 36)
val anotherPersonTuple = ("Jane Smith", 22)
println(dupPersonTuple == personTuple)
println(dupPersonTuple == anotherPersonTuple)
println(s"Person = $personTuple")

// COMMAND ----------

// MAGIC %md
// MAGIC ## Exercise 12
// MAGIC * Modify your solution to Exercise 11 to use tuples instead, in all places where they make sense.
// MAGIC * Also, the block should now return the distance and days to deliver instead of a message.

// COMMAND ----------

// TODO

// COMMAND ----------

// ANSWER
import scala.util.Random
import scala.math

// Constants
val MinX = 10
val MaxX = 2000
val MinY = 10
val MaxY = 2000
val MilesPerDay = 100

// Data
val itemName = "Programming in Scala Third Edition"
val rand = new Random()
val destPoint = (rand.nextInt(MaxX - MinX + 1) + MinX, rand.nextInt(MaxY - MinY + 1) + MinY)

// Computation
val shippingMessage = {
  val distance = Math.sqrt(destPoint._1*destPoint._1 + destPoint._2*destPoint._2)
  if (distance < 30) {
    (distance, 0)
  } else {
    val numDays = if (distance > 1000.0) ((distance - 1000.0) / 500.0) * 10 + (1000.0 / MilesPerDay) else (distance / MilesPerDay)
    (distance, Math.ceil(numDays).toInt)
  }
}


// COMMAND ----------

// MAGIC %md
// MAGIC ## NOTE:  There are better ways to model groupings of multiple values in a more readable, type-safe manner.
// MAGIC * There are also other ways to read tuples that will be covered in **pattern matching**
